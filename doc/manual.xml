<?xml version="1.0" encoding="utf-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd"
[<!ENTITY LieRing "<Package>LieRing</Package>">] >




<Book Name="LieRing">

<#Include SYSTEM "title.xml">

<TableOfContents/>

<Body>

<Chapter> <Heading>Introduction</Heading>

<Section> <Heading>Preliminaries</Heading>

A Lie ring <M>L</M> is a <M>\mathbb{Z}</M>-module equipped with a 
multiplication, denoted by a bracket <M>[~,~]</M> with 
<List>
<Item> <M>[x,x]=0</M> for all <M>x</M> in <M>L</M>,</Item>
<Item> <M>[x,[y,z]]+[z,[x,y]]+[y,[z,x]]=0</M> for all <M>x,y,z</M> in 
<M>L</M>. </Item>
</List>

Contrary to Lie algebras (which are defined over a field), Lie rings may 
have torsion elements, i.e., elements <M>x \neq 0</M> such that 
<M>mx=0</M> for some <M>m\in \mathbb{Z}</M>. <P/>

We say that a Lie ring is finite-dimensional if it is finitely-generated
as abelian group. All functions of this package deal with finite-dimensional
Lie rings. <P/>

Here is an example of a Lie ring <M>L</M> of order <M>5^6</M>. As abelian
group <M>L</M> is generated by <M>x_1,x_2,x_3,x_4,x_5</M>. We have
<M>5x_i=0</M> for <M>i=1,\ldots,4</M>, and <M>25x_5=0</M>. Furthermore,
<Display>
[x_1,x_4] = 4x_2+5x_5,~ [x_3,x_4] = 4x_1,~ [x_3,x_5]=4x_2,~
[x_4,x_5]=4x_3.
</Display>

One of the main functions of this package constructs a Lie ring given by
a multiplication table (as above) from a finite presentation. 
The Lie ring above can be obtained as follows.

<Example>
gap> L:= FreeLieRing( Integers, ["a","b"] );
&lt;Free algebra over Integers generators: a, b >
gap> a:= L.1; b:= L.2;
a
b
gap> S:= [ 5*a-(b*a)*a-((b*a)*b)*b,5*b];
[ (5)*a+(-1)*(a,(a,b))+(b,(b,(a,b))), (5)*b ]
gap> K:= FpLieRing( L, S : maxdeg:= 4 );
&lt;Lie ring with 5 generators>
gap> v:=BasisVectors( Basis(K) );
[ v_1, v_2, v_3, v_4, v_5 ]
gap> v[1]*v[4];
4*v_2+5*v_5
gap> Torsion( Basis(K) );
[ 5, 5, 5, 5, 25 ]
</Example>

</Section>

<Section> <Heading>The free Lie ring </Heading>


Let <M>X</M> be a set of letters, which we denote by <M> x_1,\ldots,x_n</M>.
Then the free magma <M>M(X)</M> on <M>X</M> is defined to be the set of all
bracketed expressions in the elements of <M>X</M>. More precisely, we have
that <M>X</M> is a subset of <M>M(X)</M> and if <M>a,b\in M(X)</M>, then also
<M>(a,b)\in M(X)</M>. The free magma has a natural binary operation <M>m</M>
with <M>m(a,b) = (a,b)</M>.<P/>
The elements of the free magma have a degree which is defined as 
<M>\deg(a,b) = \deg(a)+\deg(b)</M>. The degree of the elements of <M>X</M>
can be set to be any positive integer. (Usually this is 1, but it is 
possible to use different degrees for the elements of <M>X</M>.) <P/>
Let <M>R</M> be a ring; then the free algebra <M>A_R(X)</M> on <M>X</M> over 
<M>R</M> is the <M>R</M>-span of <M>M(X)</M>. The product on <M>A_R(X)</M>
is obtained by bilinearly extending the map <M>m</M>. <P/>
The elements of <M>M(X)</M> are called monomials of <M>A_R(X)</M>. We use the
following ordering on them. The elements of <M>X</M> are ordered arbitrarily.
Then <M> (a,b) &lt; (c,d)</M> if <M>\deg(a,b) &lt; \deg(c,d)</M>. If these
two numbers are equal, then <M> (a,b) &lt; (c,d)</M> if
<M>a &lt; c</M>, and in case <M>a=c</M>, if <M>b &lt; d</M>. Using this 
ordering we can speak of leading monomial, and leading coefficient of an element
of <M>A_R(X)</M>. Using these notions one can develop a Groebner basis theory
for ideals in <M>A_R(X)</M> (see <Cite Key="cicgra1"/> and
<Cite Key="cicgra2"/>).
<P/>
Let <M>J</M> be the ideal of <M>A_R(X)</M> generated by all elements 
<List>
<Item> <M>(a,a)</M>,</Item>
<Item> <M>(a,b)+(b,a)</M>,</Item>
<Item> <M>(a,(b,c))+(c,(a,b))+(b,(c,a))</M>,</Item>
</List>
for <M>a,b,c\in M(X)</M>. Set <M>L_R(X) = A_R(X)/J</M>, which is called 
the free Lie ring over <M>R</M> generated by <M>X</M>. <P/>
The free Lie ring is one of the central objects of this package. It can
be defined over the integers, or over a field. The free Lie rings that
can be constructed using this package rewrite their elements using
anticommutativity. The Jacobi identity is not used for rewriting; this is
because that would lead to expression swell, and sometimes tedious
rewriting of elements to a form in which that can no longer be recognised.
So, strictly speaking, we work with the free anticommutative algebra.

</Section>

<Section> <Heading>The Lazard correspondence </Heading>

Using the Baker-Campbell-Hausdorff (or BCH) formula one can define an associative multiplication
on a nilpotent Lie ring of order <M>p^n</M> and nilpotency class <M> &lt; p </M>.
This makes the Lie ring into a <M>p</M>-group of the same order and nilpotency class.
The BCH-formula also has inverses, which can be used to define an addition and a Lie
bracket on a <M>p</M>-group of class <M> &lt; p </M>. These make the group
into a Lie ring of the same order and nilpotency class. <P/>
These two operations are mutually inverse, and so define an equivalence of the 
categories of <M>p</M>-groups of class <M> &lt; p </M> and nilpotent Lie rings of
the same order and nilpotency class. This equivalence is known as the 
<E>Lazard correspondence</E> (see <Cite Key="khukhro98"/>). 
This package has functions for performing this 
correspondence, i.e., to make a <M>p</M>-group into a Lie ring and vice versa.
For the algorithms used we refer to <Cite Key="cicgravl"/>.


</Section>


</Chapter>


<Chapter> <Heading>The functions</Heading>

<Section> <Heading>The free Lie ring</Heading>

  <ManSection>
   <Meth Name="FreeLieRing"  Arg="R, names" 
         Comm="ring and list of names"/>
   <Meth Name="FreeLieRing"  Arg="R, names, deg" 
         Comm="ring and list of names and grading"/>
   <Meth Name="FreeLieRing"  Arg="R, k" 
         Comm="ring and integer"/>
   <Meth Name="FreeLieRing"  Arg="R, k, deg" 
         Comm="ring and integer and grading"/>
   <Description>

Here <A>R</A> is a ring, which has to be either the integers, or a
field. <A>names</A> is a list of strings, which will be the names of
the generators. This function returns the free Lie ring over <A>R</A>,
with generators named as in <A>names </A>. If <A>L</A> denotes the output,
then <A>L.i</A> will be the i-th generator. If a third argument <A>deg</A>
is given then this must be a list of positive integers. Then each generator
will have a degree equal to the corresponding element of the list <A>deg</A>.
<P/>
Monomials in the free Lie ring of the form <M>(a,b)</M> with <M>a>b</M>
are automatically rewritten as <M>-(b,a)</M>. Monomials of the form
<M>(a,a)</M> are rewritten as zero. There is no other rewriting done.
Therefore, the object returned by this function is strictly speaking not
the same as the free Lie ring, it rather is the free anticommutative
algebra. <P/>
Monomials in the free Lie ring are printed as bracketed expressions.
In a printed element the monomials appear in increasing order; in particular
the last monomial is the leading monomial.
<P/>
If instead of the list <A>names</A> a positive integer <A>k</A> is given, then
the free Lie ring on that number of generators is returned. Again we can
give each generator a degree different from 1 by adding a third argument
<A>deg</A>.
<Example>
gap> L:= FreeLieRing( Integers, ["a","b"] );
&lt;Free algebra over Integers generators: a, b >
gap> a:= L.1; b:= L.2;
a
b
gap> (a*b)*b+2*a*b;       
(2)*(a,b)+(-1)*(b,(a,b))
</Example>


   </Description>
  </ManSection>

<ManSection>
<Oper Name="Degree"  Arg="f" /> 
<Description>
Here <A>f</A> is an element of a free Lie ring. Its degree is 
returned.
<Example>
gap> L:= FreeLieRing( Integers, ["a","b"] );;
gap> a:= L.1;; b:= L.2;;
gap> f:=(a*b)*b+2*a*b;
(2)*(a,b)+(-1)*(b,(a,b))
gap> Degree(f);
3
</Example>
</Description>
</ManSection>


</Section>

<Section> <Heading> Creating Lie rings </Heading>

The package can deal with finite-dimensional Lie rings given by
a multiplication table (which follow the format for multiplication 
tables in the &GAP; library), and a list of moduli. This list has
to have the same length as the number of basis elements of the 
Lie ring. If the i-th element of this list is <M>m</M> then
the additive order of the i-th basis edlement if <M>m</M>.
If <M>m=0</M> then the additive order is infinite.

<ManSection>
<Filt Name="IsLieRing"/> 
<Description>
This is the category of finite-dimensional Lie rings.
</Description>
</ManSection>


<ManSection>
<Oper Name="LieRingByStructureConstants"  Arg="tor, T" /> 
<Description>
Here <A>T</A> is a multiplication table, and <A>tor</A> is a list
of moduli. This function returns the corresponding Lie ring.
In the example below we create the Lie ring with basis elements
<M>x,y,z</M>, with <M>[x,y]=z</M>, <M>3x=6y=3z=0</M>.
<P/>
The multiplication table has to be created using the &GAP; functions
for constructing multiplication tables of Lie algebras. In particular, 
we refer to the &GAP; reference manual for descriptions of the functions
<Ref Func="EmptySCTable" BookName="ref"/>
<Ref Func="SetEntrySCTable" BookName="ref"/>

<Example>
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [1,3] );
gap> LieRingByStructureConstants( [3,6,3], T );
&lt;Lie ring with 3 generators>
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name="FpLieRing"  Arg="L, R" /> 
<Description>

Here <A>L</A> is a free Lie ring defined over the integers, and <A>R</A> 
is a set of elements of
<A>L</A>. This function returns the Lie ring given by structure constants,
that is isomorphic to <A>L</A> modulo the ideal generated by <A>R</A>. <P/>
It is possible to set the option <A>maxdeg</A> to a positive value <A>d</A>. 
Then a nilpotent quotient is computed, i.e., all elements of <A>L</A> of degree 
strictly greater than <A>d</A> will be treated as relations.
<P/>
The algebra that is output by this function has an attribute, <A>CanonicalProjection</A>,
which is a function mapping elements of the free Lie ring <A>L</A> to their projections
in the output algebra.
<P/>
The algorithm behind this function has been described in <Cite Key="cicgra1"/> and
<Cite Key="cicgra2"/>.


<Example>
gap> L:= FreeLieRing( Integers, ["x","y"], [1,2] );                   
&lt;Free algebra over Integers generators: x, y >
gap> x:= L.1;; y:= L.2;;
gap> R:= [((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];
[ (-1)*(x,(x,(x,y)))+(-6)*(y,(x,y)), 
  (-3)*(x,(x,(x,(x,(x,y)))))+(-20)*(y,(x,(x,(x,y)))) ]
gap> K:= FpLieRing( L, R : maxdeg:= 15 );
&lt;Lie ring with 75 generators>
gap> f:=CanonicalProjection(K);
function( elm ) ... end
gap> f(R[1]);
0
gap> f(x);
v_1
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name="FpLieAlgebra"  Arg="L, R" /> 
<Description>

This is similar to <A>FpLieRing</A>, with the difference that the
free Lie ring <A>L</A> must be defined over a field. Then the algorithms
become a lot faster (in most cases). The result however is a Lie algebra,
and not a Lie ring.

</Description>
</ManSection>


</Section>

<Section> <Heading> Working with Lie rings </Heading>


<ManSection>
<Oper Name="Basis"  Arg="L" /> 
<Description>
Here <A>L</A> a Lie ring. Its basis is returned. <P/>
 We note that in 
<Package>LieRing</Package> Lie rings have one basis that is computed
by the system; one should not try to set a basis. 
<Example>
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [1,3] );
gap> K:= LieRingByStructureConstants( [3,6,3], T );
&lt;Lie ring with 3 generators>
gap> Basis(K); 
Basis( &lt;Lie ring with 3 generators>, [ v_1, v_2, v_3 ] )
gap> BasisVectors( Basis(K) );
[ v_1, v_2, v_3 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="StructureConstantsTable"  Arg="B" /> 
<Description>
Here <A>B</A> is the basis of a Lie ring. Its structure constants
table is returned. 
<Example>
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [1,3] );
gap> K:= LieRingByStructureConstants( [3,6,3], T );
&lt;Lie ring with 3 generators>
gap> StructureConstantsTable( Basis(K) );
[ [ [ [  ], [  ] ], [ [ 3 ], [ 1 ] ], [ [  ], [  ] ] ], 
  [ [ [ 3 ], [ -1 ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], 
  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 0 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Torsion"  Arg="B" /> 
<Description>
Here <A>B</A> is the basis of a Lie ring. The list of torsion moduli
of its basis elements is returned.
<Example>
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [1,3] );
gap> K:= LieRingByStructureConstants( [3,6,3], T );
&lt;Lie ring with 3 generators>
gap> Torsion( Basis(K) );
[ 3, 6, 3 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Coefficients"  Arg="B, elm" /> 
<Description>
Here <A>B</A> is the basis of a Lie ring, and <A>elm</A> is an element
of the same Lie ring. The coefficients of <A>elm</A> with respect to
<A>B</A> are returned.
<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;
gap> K:= FpLieRing( L, rr : maxdeg:= 6 );;
gap> C:=LieCentre(K);
&lt;Lie ring with 9 generators>
gap> Coefficients( Basis(K), Basis(C)[6] );
[ 5, 5, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
gap> Coefficients( Basis(C), Basis(C)[6] );
[ 0, 0, 0, 0, 0, 1, 0, 0, 0 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="SubLieRing"  Arg="L, gens [, string]" /> 
<Description>
Here <A>L</A> is a Lie ring, and <A>gens</A> a list of elements
of <A>L</A>. This function constructs the subring generated by the
elements in <A>gens</A>. If these elements are known to form a basis
of the subalgebra, then as a third argument the string <A>"basis"</A>
can be added. That makes the execution of the function a lot faster. <P/>
This function depends on hermite and Smith normal form computations.
Therefore in practice, for bigger inputs, it can be slow. 
<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );;                         
gap> x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; 
gap> K:= FpLieRing( L, rr : maxdeg:= 8 );
&lt;Lie ring with 41 generators>
gap> b:= Basis(K);;
gap> M:= SubLieRing( K, [ b[30], b[40] ] );
&lt;Lie ring with 6 generators>
gap> Torsion(Basis(M));
[ 3, 6, 6, 12, 360, 0 ]
gap> Basis(M)[2];
3*v_2+2*v_3+2*v_10+4*v_12+4*v_13+5*v_14+v_15+3*v_17+3*v_18+6*v_20+10*v_22+6*v_
24+6*v_25+10*v_26+4*v_27+18*v_28+30*v_29+60*v_30+360*v_31+5040*v_32
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieRingIdeal"  Arg="L, gens [, string]" /> 
<Description>
This is the same as <A>SubLieRing</A> except that the output is an ideal
(on the level of data structures that is the same as a Lie subring).
</Description>
</ManSection>


<ManSection>
<Oper Name="NaturalHomomorphismByIdeal"  Arg="L, I" /> 
<Description>
Here <A>L</A> is a Lie ring, and <A>I</A> an ideal of 
<A>L</A>. This function constructs the canonical projection of
<A>L</A> on the quotient of <A>L</A> by <A>I</A>. <P/>
We remark that it is <E>not checked</E> whether <A>I</A> is an ideal or
not. if <A>I</A> is just a subalgebra, then nothing is guaranteed about
the result of this function. <P/>
Also this function depends on Smith normal form computations; therefore
it can be slow on bigger inputs.
<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );;                         
gap> x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; 
gap> K:= FpLieRing( L, rr : maxdeg:= 8 );;
gap> b:= Basis(K);;
gap> I:= LieRingIdeal( K, [ b[29] ] );
&lt;Lie ring with 23 generators>
gap> f:= NaturalHomomorphismByIdeal( K, I );;
gap> M:= Range(f);
&lt;Lie ring with 27 generators>
gap> Torsion(Basis(M));
[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 12, 12, 12, 120, 720, 10080, 0, 0, 0, 
  0, 0, 0, 0, 0, 0 ]
gap> Image( f, b[30] );
v_16+716*v_17
gap> PreImagesRepresentative( f, Basis(M)[10] );
4*v_2+4*v_3+4*v_4+4*v_5+5*v_6+v_7+5*v_8+v_9+5*v_10+v_11+5*v_12+v_13+5*v_14+v_
24+v_25+11*v_26+v_29+10*v_30+100*v_31
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieLowerCentralSeries"  Arg="L" /> 
<Description>
Here <A>L</A> is a Lie ring. Its lower central series is 
returned. <P/>
This repeatedly constructs ideals of <A>L</A>; therefore also this
function can be rather slow on bigger inputs.
<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;
gap> K:= FpLieRing( L, rr : maxdeg:= 7 );;
gap> LieLowerCentralSeries(K);
[ &lt;Lie ring with 26 generators>, &lt;Lie ring with 24 generators>, 
  &lt;Lie ring with 23 generators>, &lt;Lie ring with 22 generators>, 
  &lt;Lie ring with 21 generators>, &lt;Lie ring with 19 generators>, 
  &lt;Lie ring with 16 generators>, &lt;Lie ring with 0 generators> ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="LieLowerPCentralSeries"  Arg="L, p" /> 
<Description>
Here <A>L</A> is a Lie ring, and <A>p</A> is a prime. The lower <A>p</A>-central series 
of <A>L</A> is returned. This is the series where the <M>L^{k+1}</M> is generated
by <M>[L,L^k]</M> and <M>pL^k</M>. Note that this may not be a finite series, if
<M>L</M> is not of exponent <M>p^n</M> (as abelian group). The function does not
check this; if the series is infinite, then it will loop forever.
<P/>
This repeatedly constructs ideals of <A>L</A>; therefore also this
function can be rather slow on bigger inputs.
<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-7*(y*x)*y, 7*((((y*x)*x)*x)*x)*x-49*(((y*x)*x)*x)*y, 
> 7*x, 49*y ];;
gap> K:= FpLieRing( L, rr : maxdeg:= 5 );;
gap> LieLowerPCentralSeries(K,7);
[ &lt;Lie ring with 11 generators>, &lt;Lie ring with 10 generators>, 
  &lt;Lie ring with 8 generators>, &lt;Lie ring with 6 generators>, 
  &lt;Lie ring with 4 generators>, &lt;Lie ring with 0 generators> ]
</Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="LieCentre"  Arg="L" /> 
<Description>
Here <A>L</A> is a Lie ring. Its centre is returned. 

<Example>
gap> L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;
gap> rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;
gap> K:= FpLieRing( L, rr : maxdeg:= 7 );;
gap> LieCentre(K);
&lt;Lie ring with 16 generators>
gap> Torsion( Basis(K) );
[ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 360, 5040, 0, 0, 0, 0, 
  0, 0, 0, 0 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TensorWithField"  Arg="L, F" /> 
<Description>
Here <A>L</A> is a Lie ring, and <A>F</A> is a field. 
This function returns the Lie algebra that is obtained by tensoring
<A>L</A> with <A>F</A>.
<Example>
gap> T:= EmptySCTable( 3, 0, "antisymmetric" );;
gap> SetEntrySCTable( T, 1, 2, [1,3] );
gap> K:= LieRingByStructureConstants( [3,6,3], T );;
gap> TensorWithField( K, GF(3) );
&lt;Lie algebra of dimension 3 over GF(3)>
gap> TensorWithField( K, GF(2) );
&lt;Lie algebra of dimension 1 over GF(2)>
gap> Dimension( TensorWithField( K, GF(5) ) );
0
</Example>
</Description>
</ManSection>


</Section>

<Section> <Heading>The Lazard correspondence</Heading>

By the Lazard correspondence we can put a Lie ring structure on a <M>p</M>-group
of class <M>&lt;p</M>. Conversely, we can define a group structure on a nilpotent 
Lie ring of order <M>p^n</M> and class <M>&lt;p</M>. The package contains functions
for doing this effectively. However, we do not work with a single object having both
the structure of a <M>p</M>-group and a Lie ring. Rather we define two objects, a 
<M>p</M>-group and a Lie ring, along with bijections between the two.

Our programs use the BCH-formula and its inverses, that have been stored in a file,
truncated at weight 14. This means that currently the package is able to deal with 
groups and algebras up to class 14. The underlying algorithms have been described
in <Cite Key="cicgravl"/>

  <ManSection>
   <Attr Name="PGroupToLieRing"  Arg="G" 
         Comm="Lie ring corresponding to p-group"/>
   <Description>

Here <A>G</A> is a <M>p</M>-group of class <M>&lt;p</M>. This function returns a record
with four components: <A>pgroup</A> (the group <A>G</A>), <A>liering</A> (the corresponding
Lie ring), <A>GtoL</A> (a function mapping elements of the group to elements of the Lie ring),
<A>LtoG</A> (a function mapping elements of the Lie ring to elements of the group).
<Example>
gap> F := FreeGroup(IsSyllableWordsFamily,"a","b","c","d", "e", "f", "g");;
gap> a := F.1;; b := F.2;; c := F.3;; d := F.4;; e := F.5;; f := F.6;; g:=F.7;;
gap> rels := [ a^13, b^13/g, c^13, d^13, e^13, f^13, g^13,  
> Comm(b,a)/c, Comm(c,a)/d, Comm(d,a)/e, Comm(e,a)/f, Comm(f,a), Comm(g,a),
> Comm(c,b)/(g^11), Comm(d,b)/g, Comm(e,b)/g, Comm(g,b), Comm(d,c)/(g^12),
> Comm(e,c), Comm(f,c), Comm(g,c), Comm(e,d), Comm(f,d), Comm(g,d), Comm(f,e), 
> Comm(g,e), Comm(g,f)];;
gap> G := PcGroupFpGroup( F/rels );
&lt;pc group of size 62748517 with 7 generators>
gap> r:= PGroupToLieRing(G);
rec( GtoL := function( g0 ) ... end, LtoG := function( x0 ) ... end, 
  liering := &lt;Lie ring with 6 generators>, 
  pgroup := &lt;pc group of size 62748517 with 7 generators> )
gap> f:= r.GtoL; h:= r.LtoG;
function( g0 ) ... end
function( x0 ) ... end
gap> L:= r.liering;
&lt;Lie ring with 6 generators>
gap> b:= Basis(L);
Basis( &lt;Lie ring with 6 generators>, [ v_1, v_2, v_3, v_4, v_5, v_6 ] )
gap> h(b[1]);
a^12*c*d^5*e^3*f^8*g^7
gap> f(h(b[1]));
v_1
</Example>


   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="LieRingToPGroup"  Arg="L" 
         Comm="p-group corresponding to Lie ring"/>
   <Description>

Here <A>L</A> is a nilpotent Lie ring of class <M>&lt;p</M> and order <M>p^n</M>. 
This function returns a record
with four components: <A>pgroup</A> (the <M>p</M>-group corresponding to <A>L</A>), 
<A>liering</A> (the Lie ring <A>L</A>), 
<A>GtoL</A> (a function mapping elements of the group to elements of the Lie ring),
<A>LtoG</A> (a function mapping elements of the Lie ring to elements of the group).
<Example>
gap> L:= FreeLieRing( Integers, ["a","b","c"] );; 
gap> a:= L.1;; b:= L.2;; c:= L.3;;
gap> rels:= [ (b*a)*b, c*a, c*b-(b*a)*a, 7^2*a, 7*b-((b*a)*a)*a, 
> 7*c-((b*a)*a)*a];;
gap> K:= FpLieRing( L, rels );
&lt;Lie ring with 5 generators>
gap> r:= LieRingToPGroup(K);
rec( GtoL := function( g0 ) ... end, LtoG := function( x0 ) ... end, 
  liering := &lt;Lie ring with 5 generators>, 
  pgroup := &lt;pc group of size 823543 with 7 generators> )
gap> G:= r.pgroup;; f:= r.LtoG;; h:= r.GtoL;;
gap> u:= 5*Basis(K)[2]+9*Basis(K)[5];
5*v_2+9*v_5
gap> f(u);
f3^2*f4^2*f5^6*f7^3
gap> h(f(u));
5*v_2+9*v_5
</Example>


   </Description>
  </ManSection>


</Section>

<Section> <Heading>The database of <M>n</M>-Engel Lie rings</Heading>

A Lie ring <M>L</M> is said to satisfy the <M>n</M>-Engel condition if for all
<M>x,y \in L</M> we have <M>(ad x)^n (y) = 0</M>.
The package &LieRing; contains a small database of Lie rings that satisfy an
<M>n</M>-Engel condition. 
They have been computed with the algorithms described in <Cite Key="cicgra1"/> and
<Cite Key="cicgra2"/>. <P/><P/>
Currently the database contains the "freeest" (or "largest") <M>n</M>-Engel Lie rings
with <M>k</M> generators for <M>(n,k) = (3,2), (3,3), (3,4), (4,2), (4,3)</M>. 

<ManSection>
<Oper Name="SmallNEngelLieRing"  Arg="n, k" /> 
<Description>
This returns the biggest <A>n</A>-Engel Lie ring with <A>k</A> generators, for the values
of <A>n,k</A> indicated above. For other values an error is raised.
<Example>
gap> L:= SmallNEngelLieRing( 4, 3 );
&lt;Lie ring with 133 generators>
gap> x:= 10*Basis(L)[1]+7*Basis(L)[10]+19*Basis(L)[89];
7*v_10+19*v_89
gap> ForAll( Basis(L), y -> IsZero( x*(x*(x*(x*y))) ) );
true
gap> K:= TensorWithField( L, GF(3) );
&lt;Lie algebra of dimension 83 over GF(3)>
gap> x:= Random(K);;
gap> ForAll( Basis(K), y -> IsZero( x*(x*(x*(x*y))) ) );
true
</Example>
</Description>
</ManSection>


</Section>

</Chapter>

</Body>

<Bibliography Databases="liering" />

<TheIndex/>


</Book>

